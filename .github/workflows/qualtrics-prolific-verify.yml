name: Verify Qualtrics ↔ Prolific Survey Setup

on:
  workflow_dispatch:
    inputs:
      survey_id:
        description: 'Optional Survey ID (defaults to QUALTRICS_SURVEY_ID env var)'
        required: false
        type: string

permissions:
  contents: read

jobs:
  verify:
    runs-on: ubuntu-latest
    environment: qualtrics-prod
    env:
      QUALTRICS_API_TOKEN: ${{ secrets.QUALTRICS_API_TOKEN }}
      QUALTRICS_BASE_URL: ${{ vars.QUALTRICS_BASE_URL }}
      QUALTRICS_SURVEY_ID: ${{ vars.QUALTRICS_SURVEY_ID }}
      INPUT_SURVEY_ID: ${{ inputs.survey_id }}
    steps:
      - name: Verify Qualtrics configuration (API-only)
        shell: bash
        run: |
          set -euo pipefail

          if [[ -z "${QUALTRICS_API_TOKEN:-}" ]]; then
            echo "Missing secret QUALTRICS_API_TOKEN in environment qualtrics-prod" >&2
            exit 1
          fi

          if [[ -z "${QUALTRICS_BASE_URL:-}" ]]; then
            echo "Missing env var QUALTRICS_BASE_URL in environment qualtrics-prod" >&2
            exit 1
          fi

          BASE_URL="${QUALTRICS_BASE_URL%/}"
          SURVEY_ID="${INPUT_SURVEY_ID:-${QUALTRICS_SURVEY_ID:-}}"

          if [[ -z "${SURVEY_ID}" ]]; then
            echo "Missing survey id. Set QUALTRICS_SURVEY_ID or pass workflow input survey_id." >&2
            exit 1
          fi

          TMP_DIR="${RUNNER_TEMP:-/tmp}"
          DEF_JSON="$TMP_DIR/qualtrics-survey-definition.json"
          OPTIONS_JSON="$TMP_DIR/qualtrics-survey-options.json"
          START_JSON="$TMP_DIR/qualtrics-export-start.json"
          STATUS_JSON="$TMP_DIR/qualtrics-export-status.json"
          ZIP_PATH="$TMP_DIR/qualtrics-survey-export.zip"
          OUT_DIR="$TMP_DIR/qualtrics-survey-export"

          echo "## Qualtrics ↔ Prolific Verification" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Survey ID:** ${SURVEY_ID}" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Base URL:** ${BASE_URL}" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Mode:** API-only (no live survey traffic)" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Provide deterministic links for manual end-to-end validation.
          SURVEY_LINK_BASE="$BASE_URL/jfe/form/${SURVEY_ID}"
          WEBSITE_COMPLETE_URL="${TABS_WEBSITE_COMPLETE_URL:-https://technologyadoptionbarriers.org/survey-complete}"
          urlencode() {
            python3 -c "import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1], safe=''))" "$1"
          }
          WEBSITE_COMPLETE_URL_ENC="$(urlencode "$WEBSITE_COMPLETE_URL")"

          # Intentionally a placeholder: Prolific completion codes are sensitive.
          PROLIFIC_COMPLETE_URL_PLACEHOLDER='https://app.prolific.com/submissions/complete?cc=<YOUR_CODE>'
          PROLIFIC_COMPLETE_URL_PLACEHOLDER_ENC="$(urlencode "$PROLIFIC_COMPLETE_URL_PLACEHOLDER")"

          echo "### Manual end-to-end test links" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "If you enabled **redirect lockdown** in the LIVE apply workflow, inbound \\"COMPLETE_URL\\" is ignored (only \\"PROLIFIC_PID\\" presence matters)." >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "**Website/direct:**" >> "$GITHUB_STEP_SUMMARY"
          echo "```text" >> "$GITHUB_STEP_SUMMARY"
          echo "${SURVEY_LINK_BASE}?SOURCE=TABS_Website&COMPLETE_URL=${WEBSITE_COMPLETE_URL_ENC}" >> "$GITHUB_STEP_SUMMARY"
          echo "```" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "**Prolific-sim (placeholder COMPLETE_URL):**" >> "$GITHUB_STEP_SUMMARY"
          echo "```text" >> "$GITHUB_STEP_SUMMARY"
          echo "${SURVEY_LINK_BASE}?PROLIFIC_PID=TEST_PID&STUDY_ID=TEST_STUDY&SESSION_ID=TEST_SESSION&SOURCE=prolific&COMPLETE_URL=${PROLIFIC_COMPLETE_URL_PLACEHOLDER_ENC}" >> "$GITHUB_STEP_SUMMARY"
          echo "```" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Always try to read survey options (Header + EOS redirect config).
          has_prolific_script_from_options=false
          has_completion_redirect_from_options=false
          has_redirect_termination_from_options=false

          options_url="$BASE_URL/API/v3/survey-definitions/${SURVEY_ID}/options"
          http_code=$(curl -sS -o "$OPTIONS_JSON" -w "%{http_code}" \
            -H "X-API-TOKEN: ${QUALTRICS_API_TOKEN}" \
            -H "Accept: application/json" \
            "$options_url" || true)

          if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
            # Script marker: look for Prolific Qualtrics loader.
            if jq -r '.result.Header // ""' "$OPTIONS_JSON" | grep -Eq 'assets\.prolific\.com/.*/qualtrics/qualtrics\.min\.js'; then
              has_prolific_script_from_options=true
            fi

            # Redirect marker: EOSRedirectURL should use piped text so Prolific vs non-Prolific
            # respondents can be redirected differently.
            if jq -r '.result.EOSRedirectURL // ""' "$OPTIONS_JSON" | grep -Eq '\$\{e://Field/COMPLETE_URL\}'; then
              has_completion_redirect_from_options=true
            fi

            # Termination mode must be Redirect in some tenants.
            if jq -r '.result.SurveyTermination // ""' "$OPTIONS_JSON" | grep -Eq '^(Redirect|redirect)$'; then
              has_redirect_termination_from_options=true
            fi
          else
            echo "::warning::Could not fetch survey options (HTTP $http_code): $options_url" >&2
          fi

          # Prefer fetching the survey definition directly. Some Qualtrics brands return 404
          # for the Survey Export API even when normal /surveys endpoints work.
          scan_path=""
          scan_source=""

          definition_url_1="$BASE_URL/API/v3/survey-definitions/${SURVEY_ID}"
          definition_url_2="$BASE_URL/API/v3/surveys/${SURVEY_ID}/definition"

          for url in "$definition_url_1" "$definition_url_2"; do
            http_code=$(curl -sS -o "$DEF_JSON" -w "%{http_code}" \
              -H "X-API-TOKEN: ${QUALTRICS_API_TOKEN}" \
              -H "Accept: application/json" \
              "$url" || true)

            if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
              scan_path="$DEF_JSON"
              scan_source="$url"
              break
            fi
          done

          if [[ -z "${scan_path}" ]]; then
            # Fallback: export the survey definition (QSF). This avoids loading the live survey.
            # NOTE: Qualtrics export APIs can be asynchronous; we poll for completion.
            EXPORT_URL="$BASE_URL/API/v3/surveys/${SURVEY_ID}/export"
            http_code=$(curl -sS -o "$START_JSON" -w "%{http_code}" \
              -X POST \
              -H "X-API-TOKEN: ${QUALTRICS_API_TOKEN}" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              -d '{"format":"qsf"}' \
              "$EXPORT_URL" || true)

            if [[ "$http_code" -lt 200 || "$http_code" -ge 300 ]]; then
              echo "::error::Failed to fetch survey definition and could not start survey export (HTTP $http_code): $EXPORT_URL" >&2
              echo "Survey definition endpoints tried:" >&2
              echo "- $definition_url_1" >&2
              echo "- $definition_url_2" >&2
              echo "Export endpoint:" >&2
              echo "- $EXPORT_URL" >&2
              echo "" >&2
              # Error bodies for 404/401/403 should not include survey contents; keep small.
              head -c 2000 "$START_JSON" || true
              exit 1
            fi

            progress_id=$(jq -r '.result.progressId // .result.id // empty' "$START_JSON")
            if [[ -z "${progress_id}" ]]; then
              echo "::error::Could not read progressId from export start response." >&2
              exit 1
            fi

            file_id=""
            for attempt in $(seq 1 30); do
              STATUS_URL="$BASE_URL/API/v3/surveys/${SURVEY_ID}/export/${progress_id}"
              http_code=$(curl -sS -o "$STATUS_JSON" -w "%{http_code}" \
                -H "X-API-TOKEN: ${QUALTRICS_API_TOKEN}" \
                -H "Accept: application/json" \
                "$STATUS_URL" || true)

              if [[ "$http_code" -lt 200 || "$http_code" -ge 300 ]]; then
                echo "::error::Export status check failed (HTTP $http_code): $STATUS_URL" >&2
                head -c 2000 "$STATUS_JSON" || true
                exit 1
              fi

              status=$(jq -r '.result.status // .result.state // empty' "$STATUS_JSON")
              file_id=$(jq -r '.result.fileId // .result.file_id // empty' "$STATUS_JSON")

              if [[ "${status}" == "complete" || "${status}" == "completed" ]]; then
                break
              fi

              if [[ "${status}" == "failed" ]]; then
                echo "::error::Qualtrics export failed." >&2
                exit 1
              fi

              sleep 2
            done

            if [[ -z "${file_id}" ]]; then
              # Some Qualtrics brands return fileId only after completion; try reading it one more time.
              file_id=$(jq -r '.result.fileId // .result.file_id // empty' "$STATUS_JSON")
            fi

            if [[ -z "${file_id}" ]]; then
              echo "::error::Export did not return a fileId after polling." >&2
              exit 1
            fi

            FILE_URL="$BASE_URL/API/v3/surveys/${SURVEY_ID}/export/${file_id}/file"
            http_code=$(curl -sS -L -o "$ZIP_PATH" -w "%{http_code}" \
              -H "X-API-TOKEN: ${QUALTRICS_API_TOKEN}" \
              "$FILE_URL" || true)

            if [[ "$http_code" -lt 200 || "$http_code" -ge 300 ]]; then
              echo "::error::Failed to download export file (HTTP $http_code): $FILE_URL" >&2
              exit 1
            fi

            rm -rf "$OUT_DIR"
            mkdir -p "$OUT_DIR"
            unzip -q "$ZIP_PATH" -d "$OUT_DIR"

            qsf_path=$(find "$OUT_DIR" -maxdepth 3 -type f -name "*.qsf" -print -quit)
            if [[ -z "${qsf_path}" ]]; then
              echo "::error::Could not find a .qsf file in the exported archive." >&2
              exit 1
            fi

            scan_path="$qsf_path"
            scan_source="$EXPORT_URL"
          fi

          echo "- **Definition source:** ${scan_source}" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Checks (do NOT print file contents)
          has_prolific_script=false
          has_prolific_pid=false
          has_study_id=false
          has_session_id=false
          has_source=false
          has_complete_url=false

          # Qualtrics exports are JSON; URLs may appear with escaped slashes (e.g. \/).
          if grep -Eq 'assets\.prolific\.com(\\/|/)assets(\\/|/)js(\\/|/)qualtrics(\\/|/)qualtrics\.min\.js' "$scan_path"; then
            has_prolific_script=true
          fi

          if [[ "$has_prolific_script_from_options" == "true" ]]; then
            has_prolific_script=true
          fi

          if grep -q "PROLIFIC_PID" "$scan_path"; then
            has_prolific_pid=true
          fi

          if grep -q "STUDY_ID" "$scan_path"; then
            has_study_id=true
          fi

          if grep -q "SESSION_ID" "$scan_path"; then
            has_session_id=true
          fi

          if grep -q "SOURCE" "$scan_path"; then
            has_source=true
          fi

          if grep -q "COMPLETE_URL" "$scan_path"; then
            has_complete_url=true
          fi

          # If definition endpoints work but don't surface embedded data markers, fall back to QSF export.
          if [[ "$scan_source" == "$definition_url_1" || "$scan_source" == "$definition_url_2" ]]; then
            if [[ "$has_prolific_pid" != "true" || "$has_study_id" != "true" || "$has_session_id" != "true" || "$has_source" != "true" || "$has_complete_url" != "true" ]]; then
              echo "::notice::Definition source did not include all embedded data markers; falling back to QSF export for verification." >&2

              EXPORT_URL="$BASE_URL/API/v3/surveys/${SURVEY_ID}/export"
              http_code=$(curl -sS -o "$START_JSON" -w "%{http_code}" \
                -X POST \
                -H "X-API-TOKEN: ${QUALTRICS_API_TOKEN}" \
                -H "Accept: application/json" \
                -H "Content-Type: application/json" \
                -d '{"format":"qsf"}' \
                "$EXPORT_URL" || true)

              if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
                progress_id=$(jq -r '.result.progressId // .result.id // empty' "$START_JSON")
                if [[ -z "${progress_id}" ]]; then
                  echo "::warning::Could not read progressId from export start response; keeping definition-based scan." >&2
                else
                  file_id=""
                  for attempt in $(seq 1 30); do
                    STATUS_URL="$BASE_URL/API/v3/surveys/${SURVEY_ID}/export/${progress_id}"
                    http_code=$(curl -sS -o "$STATUS_JSON" -w "%{http_code}" \
                      -H "X-API-TOKEN: ${QUALTRICS_API_TOKEN}" \
                      -H "Accept: application/json" \
                      "$STATUS_URL" || true)

                    if [[ "$http_code" -lt 200 || "$http_code" -ge 300 ]]; then
                      break
                    fi

                    status=$(jq -r '.result.status // .result.state // empty' "$STATUS_JSON")
                    file_id=$(jq -r '.result.fileId // .result.file_id // empty' "$STATUS_JSON")

                    if [[ "${status}" == "complete" || "${status}" == "completed" ]]; then
                      break
                    fi
                    if [[ "${status}" == "failed" ]]; then
                      break
                    fi

                    sleep 2
                  done

                  if [[ -n "${file_id}" ]]; then
                    FILE_URL="$BASE_URL/API/v3/surveys/${SURVEY_ID}/export/${file_id}/file"
                    http_code=$(curl -sS -L -o "$ZIP_PATH" -w "%{http_code}" \
                      -H "X-API-TOKEN: ${QUALTRICS_API_TOKEN}" \
                      "$FILE_URL" || true)

                    if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
                      rm -rf "$OUT_DIR"
                      mkdir -p "$OUT_DIR"
                      unzip -q "$ZIP_PATH" -d "$OUT_DIR"
                      qsf_path=$(find "$OUT_DIR" -maxdepth 3 -type f -name "*.qsf" -print -quit)

                      if [[ -n "${qsf_path}" ]]; then
                        scan_path="$qsf_path"
                        scan_source="$EXPORT_URL"

                        # Recompute embedded data checks from exported QSF.
                        has_prolific_pid=false
                        has_study_id=false
                        has_session_id=false
                        has_source=false
                        has_complete_url=false
                        if grep -q "PROLIFIC_PID" "$scan_path"; then has_prolific_pid=true; fi
                        if grep -q "STUDY_ID" "$scan_path"; then has_study_id=true; fi
                        if grep -q "SESSION_ID" "$scan_path"; then has_session_id=true; fi
                        if grep -q "SOURCE" "$scan_path"; then has_source=true; fi
                        if grep -q "COMPLETE_URL" "$scan_path"; then has_complete_url=true; fi
                      fi
                    fi
                  fi
                fi
              else
                echo "::warning::Could not start QSF export (HTTP $http_code); keeping definition-based scan." >&2
              fi
            fi
          fi

          echo "### Checks" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Check | Result |" >> "$GITHUB_STEP_SUMMARY"
          echo "|---|---|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Prolific authenticity script marker present | ${has_prolific_script} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Options: SurveyTermination is Redirect | ${has_redirect_termination_from_options} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Options: EOSRedirectURL is ${e://Field/COMPLETE_URL} | ${has_completion_redirect_from_options} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Embedded Data field present: PROLIFIC_PID | ${has_prolific_pid} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Embedded Data field present: STUDY_ID | ${has_study_id} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Embedded Data field present: SESSION_ID | ${has_session_id} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Embedded Data field present: SOURCE | ${has_source} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Embedded Data field present: COMPLETE_URL | ${has_complete_url} |" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          has_errors=false

          if [[ "$has_prolific_script" != "true" ]]; then
            echo "::error::Missing Prolific authenticity script marker in survey export." >&2
            has_errors=true
          fi

          if [[ "$has_prolific_pid" != "true" ]]; then
            echo "::error::Missing Embedded Data field marker: PROLIFIC_PID" >&2
            has_errors=true
          fi

          if [[ "$has_study_id" != "true" ]]; then
            echo "::error::Missing Embedded Data field marker: STUDY_ID" >&2
            has_errors=true
          fi

          if [[ "$has_session_id" != "true" ]]; then
            echo "::error::Missing Embedded Data field marker: SESSION_ID" >&2
            has_errors=true
          fi

          if [[ "$has_source" != "true" ]]; then
            echo "::error::Missing Embedded Data field marker: SOURCE" >&2
            has_errors=true
          fi

          if [[ "$has_complete_url" != "true" ]]; then
            echo "::error::Missing Embedded Data field marker: COMPLETE_URL" >&2
            has_errors=true
          fi

          if [[ "$has_completion_redirect_from_options" != "true" ]]; then
            echo "::error::Options EOSRedirectURL is not set to ${e://Field/COMPLETE_URL}." >&2
            has_errors=true
          fi

          if [[ "$has_errors" == "true" ]]; then
            exit 1
          fi

          echo "✅ Verification passed."
